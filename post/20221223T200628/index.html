<!DOCTYPE html>
<html>
<head>
<title>Emacs gnus emacs 的邮件系统，以 outlook 邮箱为例 - 手指骑士的病房</title>
<link rel="icon" href="/static/favicon.ico"><link href= "/static/style/style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div class="header">
<div class="home-page">
<a href="/">手指骑士的病房</a></div><div class="nav">
<div class="nav item">
<a href="/tags">标签</a>
</div>
<div class="nav item">
<a href="/archive">归档</a>
</div>
<div class="nav item">
<a href="/about">关于</a>
</div>
</div>
</div>
<div class="main">
<div id="preamble" class="status">
<link rel="stylesheet" href="/static/highlight/dracula.css"><div class="toc">
<h2 class="toc-title"> TOC </h2>
<nav id="TableOfContents">

<ul>
<li>
<a href="#orgf32e480"> 简介 </a></li>
<li>
<a href="#org7c72a52"> 配置 </a>
<ul>
<li>
<a href="#org519828d"> 基本配置 </a></li>
<li>
<a href="#orgd3403e5"> 邮箱配置 </a>
<ul>
<li>
<a href="#orgafc48ca"> 收件服务器配置 </a></li>
<li>
<a href="#org5bc5607"> 发件服务器配置 </a></li>
<li>
<a href="#org5134b43"> 身份验证配置 </a></li>
<li>
<a href="#org3bc9a65"> 使用 </a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#org29e46ce"> GNUS 结构 </a></li>
<li>
<a href="#org731b8d8"> Group </a>
<ul>
<li>
<a href="#orgbb2800c"> 组操作 </a>
<ul>
<li>
<a href="#orgcd7697d"> 组订阅 </a></li>
<li>
<a href="#orgedbb909"> 组光标移动 </a></li>
<li>
<a href="#org10e7598"> 组打开退出 </a></li>
<li>
<a href="#org4c2d9d7"> 组标记 </a></li>
<li>
<a href="#orgdeb88cb"> 组管理 </a></li>
<li>
<a href="#orgbfcea02"> 组显示 </a></li>
<li>
<a href="#org3f7e525"> 组排序 </a></li>
<li>
<a href="#org963f456"> 组其他操作 </a></li>
</ul>
</li>
<li>
<a href="#orged6982a"> 组参数 </a></li>
<li>
<a href="#orgcba538e"> 话题 </a></li>
</ul>
</li>
<li>
<a href="#org815dac6"> Summary Buffer </a>
<ul>
<li>
<a href="#orge9fff6d"> 纲要操作 </a>
<ul>
<li>
<a href="#orge7fa2c9"> 纲要打开与退出 </a></li>
<li>
<a href="#orga8c2389"> 纲要光标移动 </a></li>
<li>
<a href="#org47c37a9"> 文章滚动与操作 </a></li>
<li>
<a href="#org4b4b8ff"> 文章显示 </a></li>
<li>
<a href="#orge3412d1"> 邮件操作 </a></li>
<li>
<a href="#org24539b9"> 文章搜索 </a></li>
</ul>
</li>
<li>
<a href="#org1d925cd"> 文章发送 </a>
<ul>
<li>
<a href="#orgec1ff29"> 邮件撰写 </a></li>
<li>
<a href="#org7fb771c"> 文章回复 </a></li>
<li>
<a href="#org4b3599c"> 文章撰写 </a></li>
</ul>
</li>
<li>
<a href="#org6eb2643"> 文章标记 </a>
<ul>
<li>
<a href="#org01d2a2f"> 文章标记样式 </a></li>
<li>
<a href="#org31d3aab"> 文章标记操作 </a></li>
</ul>
</li>
<li>
<a href="#orgd89cb79"> 文章排序 </a></li>
</ul>
</li>
<li>
<a href="#org8b803ba"> Article Buffer </a></li>
<li>
<a href="#org583e146"> 信息发送 </a>
<ul>
<li>
<ul>
<li>
<a href="#org501ac16"> 定时发送 </a></li>
<li>
<a href="#org101efa5"> 草稿 </a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#org7101619"> RSS </a>
<ul>
<li>
<a href="#org06f0263"> 通过 Feeddd 获取微信公众号 </a></li>
</ul>
</li>
<li>
<a href="#orge468ec4"> 后记 </a></li>
</ul>
</nav>
</div>
<h1 class="post-title"> Emacs gnus emacs 的邮件系统，以 outlook 邮箱为例 </h1>
<div class="post-date">2023-05-19</div>
<div class="taglist"><a href="/tag/emacs"> #emacs </a>
<a href="/tag/gnus"> #gnus </a>
<a href="/tag/rss"> #rss </a>
</div>
</div>
<div id="content">

<div id="outline-container-orgf32e480" class="outline-2">
<h2 id="orgf32e480">简介</h2>
<div class="outline-text-2" id="text-orgf32e480">
<p>
GNUS, Gnus Network User Services, 是 Emacs 的一个信息接收应用，支持接收和发送邮件、新闻，也能用于接收 RSS<sup>[<a id="fnr:1.1" class="footref" href="#fn:1">1</a>]</sup>  。我想换掉 <a href="https://vivaldi.com/" target="_blank">Vivaldi</a> 浏览器，转而用一个更加简洁、更加轻量的浏览器 <a href="https://minbrowser.org/" target="_blank">Min</a> -&#x2013;&#x2014; 有一说一，习惯了 Min 之后感觉真的很清爽，虽然 vivaldi 也能在外观和界面上做到，只是它内置的工具太多了。准备集成 Emac, 通过 GNUS 把邮件和 RSS 都搬到上边，这样 vivaldi 对我而言就没啥优势了。
</p>

<p>
GNUS 的文档《<a href="http://www.gnus.org/manual/big-gnus.html" target="_blank">Gnus Manual</a>》，写的非常详细 -&#x2013;&#x2014; 也就是非常复杂，而且它还涉及到各种信息通信的技术。我了解得少，只想要一个简单的配置，没有花时间看，后面空了再慢慢补上。
</p>

<p>
于是我四面八方搜罗资料，参考论坛的前辈的分享，终于让我写出了一个能用的配置： <a href="https://emacs-china.org/t/emacs-send-mail-rmail-and-gnus/11730" target="_blank">Emacs收发邮件完全操作指南: Send-Mail, Rmail and Gnus - Emacs-general - Emacs China</a> 。
</p>

<p>
同时还有陈斌老师的教程： <a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org" target="_blank">mastering-emacs-in-one-year-guide/gnus-guide-en.org at master · redguardtoo/mastering-emacs-in-one-year-guide · GitHub</a>
</p>
</div>
</div>

<div id="outline-container-org7c72a52" class="outline-2">
<h2 id="org7c72a52">配置</h2>
<div class="outline-text-2" id="text-org7c72a52">
<p>
首先说明的是，我目前的 Emacs 版本（28.2）已经内置了 GNUS 模块，直接 <code>requrire</code> 就能用了。
</p>

<p>
根据官方文档， GNUS 有自己的配置文件 <code>~/.gnus.el</code> ，就像 Emacs 的 <code>init.el</code> 一样。
</p>

<p>
目前我的配置已经使用了 setup 的模块化配置，有一些设定好的参数在 <code>.emacs.d/init.el</code> 里面，同时为了保持配置的一贯性，我决定还是把大部分配置写在这里 <sup>[<a id="fnr:2.1" class="footref" href="#fn:2">2</a>]</sup> ；对于一些隐私信息如邮箱名字、 RSS 订阅列表等就写在 GNUS 的 init 中留在本地。
</p>

<p>
以下的配置写在 <code>~/.eamcs.d</code> 或在 <code>/.gnus.el</code> 中都可以。
</p>
</div>

<div id="outline-container-org519828d" class="outline-3">
<h3 id="org519828d">基本配置</h3>
<div class="outline-text-3" id="text-org519828d">
<div class="org-src-container">
<pre><code class="language-lisp">(setq gnus-init-file "~/.gnus.el"
      gnus-home-directory "~/.emacs.d/etc/gnus"
      gnus-use-cache)</code></pre>
</div>
<ul class="org-ul">
<li>首先要告诉 GNUS, 它的初始化文件在哪里</li>
<li>设置 GNUS 的数据和配置的存放目录目录。它默认是家目录，如果不改，后续就会有各种奇怪的目录出现</li>
<li>使用缓存，可以离线查看缓存了的邮件</li>
</ul>
</div>
</div>

<div id="outline-container-orgd3403e5" class="outline-3">
<h3 id="orgd3403e5">邮箱配置</h3>
<div class="outline-text-3" id="text-orgd3403e5">
<p>
前面给的论坛里面的分享是用 QQ 邮箱为例子，我用的是 Outlook, 我就以 Outlook 为例。
</p>

<p>
首先，你需要确定自己的邮箱是支持第三方的。大部分邮箱都支持，但还是有比如 Tutanota 就不支持。
</p>

<p>
然后去找到你用邮箱的配置，一般在搜索引擎上就行找到，关键词“xx邮箱 第三方配置”。
</p>


<figure id="org3006256">
<a href="/assets/d3bb22947ecd47592526f8977582062b.png" target="_blank" target="_blank"><img src="/assets/d3bb22947ecd47592526f8977582062b.png" alt="d3bb22947ecd47592526f8977582062b.png"></a>

</figure>


<figure id="org6f4efe5">
<a href="/assets/469331868c67ddf07278524a82dddb7c.png" target="_blank" target="_blank"><img src="/assets/469331868c67ddf07278524a82dddb7c.png" alt="469331868c67ddf07278524a82dddb7c.png"></a>

</figure>

<p>
最好是在官网上看，如果看其他博主分享的话要注意发文时间，因为服务器地址端口可能会更新的。
</p>

<p>
得到如下信息：
</p>
<ul class="org-ul">
<li>收件服务器
<ul class="org-ul">
<li>协议 <code>imap</code></li>
<li>地址  <code>outlook.office365.com</code></li>
<li>端口 <code>993</code></li>
<li>加密方式 <code>ssl</code></li>
</ul></li>
<li>发件服务器
<ul class="org-ul">
<li>协议 <code>smtp</code></li>
<li>地址  <code>osmtp.office365.com</code></li>
<li>端口 <code>587</code></li>
<li>加密方式 <code>startssl</code></li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgafc48ca" class="outline-4">
<h4 id="orgafc48ca">收件服务器配置</h4>
<div class="outline-text-4" id="text-orgafc48ca">
<p>
我用的是 imap 的协议，如下：
</p>

<div class="org-src-container">
<pre><code class="language-lisp">(setq gnus-select-method
      '(nnimap "outlook"
               (nnimap-address "outlook.office365.com")
               (nnimap-server-port 993)
               (nnimap-stream ssl)))</code></pre>
</div>
</div>
</div>

<div id="outline-container-org5bc5607" class="outline-4">
<h4 id="org5bc5607">发件服务器配置</h4>
<div class="outline-text-4" id="text-org5bc5607">
<div class="org-src-container">
<pre><code class="language-lisp">(setq send-mail-function 'smtpmail-send-it
      smtpmail-smtp-server "smtp.office365.com"
      smtpmail-smtp-service 587)</code></pre>
</div>

<p>
不需要配置加密方式。
</p>
</div>
</div>

<div id="outline-container-org5134b43" class="outline-4">
<h4 id="org5134b43">身份验证配置</h4>
<div class="outline-text-4" id="text-org5134b43">
<p>
身份验证信息是写在一个单独文件里，变量 <code>auth-sources</code> 说明了验证文件的位置，默认是 <code>("~/.authinfo" "~/.authinfo.gpg" "~/.netrc")</code>, 你可以根据自己的需要改，或者就写在默认的 <code>~/.authinfo</code> 也行。
</p>

<div class="org-src-container">
<pre><code class="language-plaintext">machine <server> login <your-email@example.com> password <your password> port <port>
machine <server> login <your-email@example.com> password <your password> port <port></code></pre>
</div>

<p>
有两条记录，分别是<b>收件服务器</b>和<b>发件服务器</b>的验证。
</p>
<ul class="org-ul">
<li><code>machine</code> 后边写上服务器的地址</li>
<li><code>login</code> 后边跟上你的邮箱地址</li>
<li><code>password</code> 后边是密码</li>
<li><code>port</code> 后边是对应的端口</li>
</ul>

<p>
以前面的信息为例就是：
</p>
<div class="org-src-container">
<pre><code class="language-plaintext">machine outlook.office365.com login <user>@outlook.com password <password> port 993
machine smtp.office365.com login <user>@outlook.com password <password> port 587</code></pre>
</div>

<p>
可以使用 Emacs 自带的加密系统加密：
</p>
<ol class="org-ol">
<li>新建一个 <code>~/.authinfo.gpg</code></li>
<li>在首行键入 <code>-*- epa-file-encrypt-to: nil -*-</code></li>
<li>输入上面那两行验证条目</li>
<li>保存，然后会要求输入密码</li>
</ol>
</div>
</div>

<div id="outline-container-org3bc9a65" class="outline-4">
<h4 id="org3bc9a65">使用</h4>
<div class="outline-text-4" id="text-org3bc9a65">
<p>
至此，一个简单的邮箱配置就完成了。打开 Emacs, 然后 <code>M-x gnus RET</code> 就可以进入到 GNUS 的界面了。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org29e46ce" class="outline-2">
<h2 id="org29e46ce">GNUS 结构</h2>
<div class="outline-text-2" id="text-org29e46ce">
<p>
GNUS 有三大部分构成： Server, Group 和 Article. 简单理解：
</p>
<ul class="org-ul">
<li><b>Server</b> 就是一个服务器，每不同的邮箱帐号就对应不同的 Server 。</li>
<li><b>Group</b> 是服务器 Server 下的文件夹</li>
<li><b>Article</b> 是组 Group 下的邮件</li>
</ul>

<p>
其结构如下：
</p>
<div class="org-src-container">
<pre class="mermaid">graph TD;

A[Server:outlook.com] --> B[Group:Inbox]
A --> C[Group:Send]
A --> D[Group:Trush]

B --> B1[Article]
B --> B2[Article]
B --> B3[Article]

C --> C1[Article]
C --> C2[Article]
C --> C3[Article]

D --> D1[Article]
D --> D2[Article]
D --> D3[Article]</pre>
</div>

<p>
由此也衍生出了不同的 <b>buffer</b> 用于显示不同的信息：
</p>
<ul class="org-ul">
<li><code>*Server*</code>, 服务器列表，用于展示服务器</li>
<li><code>*Group*</code>, 组列表，用于展示服务器下的组</li>
<li><code>*Summary*</code>, 文章列表，用于展示组下的文章</li>
<li><code>*Article*</code> ，文章的具体内容</li>
</ul>
</div>
</div>

<div id="outline-container-org731b8d8" class="outline-2">
<h2 id="org731b8d8">Group</h2>
<div class="outline-text-2" id="text-org731b8d8">
<p>
组列表，展示当前服务器下所有的组。区分订阅（subscript）和可见（visible）。
</p>

<ul class="org-ul">
<li>订阅是告诉 GNUS 那些组需要去获取（fetch）。比如 Outlook, 它内置了很多文件夹如笔记（Notes）、存档、同步等，我删不掉且不会用到，那么我㠇可以取消订阅它 (unsubscribe), 之后就不会去获取这个文件夹的内容了。默认是所有文件夹都订阅的。在一个新帐号刚配置时，会默认订阅该帐号下所有的文件夹。订阅设置接下来就会说到。</li>
<li>可见是指，对于订阅的组，哪些会展示在 Group Buffer 上。默认情况下，有未读邮件的组可见，其它组不可见。但我有点不习惯这个，在<a href="#orged6982a">组参数</a>那里会说怎么调。</li>
</ul>
</div>

<div id="outline-container-orgbb2800c" class="outline-3">
<h3 id="orgbb2800c">组操作</h3>
<div class="outline-text-3" id="text-orgbb2800c">
</div>
<div id="outline-container-orgcd7697d" class="outline-4">
<h4 id="orgcd7697d">组订阅</h4>
<div class="outline-text-4" id="text-orgcd7697d">
<ul class="org-ul">
<li>S t （或 u） 订阅开关，如果已经订阅设为不订阅，如果不订阅设为订阅。</li>
<li>S s （或 U） 弹出 minibuffer, 选择一个组，然后使用订阅开关</li>
</ul>

<p>
GNUS 是通过组的一个 level 来判断是否要订阅或者不订阅某个组。所以如果不想订阅，可以在配置里面写：
</p>
<div class="org-src-container">
<pre><code class="language-lisp">(setq gnus-unsubscribed-groups '("Notes"
                                 ;; ...
                                 ))
(defun my/gnus-handle-unscribed-groups ()
  (dolist (group gnus-unsubscribed-groups)
    (gnus-group-change-level group
                             gnus-level-unsubscribed
                             gnus-level-default-subscribed)))
(add-hook 'gnus-group-prepare #""my/gnus-handle-unscribed-groups)</code></pre>
</div>

<p>
此时依然可以在 Buffer 里面看到它们，但是会多一个 <code>U</code> 的标志，表示不订阅。
</p>
</div>
</div>

<div id="outline-container-orgedbb909" class="outline-4">
<h4 id="orgedbb909">组光标移动</h4>
<div class="outline-text-4" id="text-orgedbb909">
<ul class="org-ul">
<li>n 移动到下一个含有<b>未读消息</b>的组</li>
<li>p 移动到上一个含有<b>未读消息</b>的组</li>
<li>N 移动到下一个组</li>
<li>P 移动到上一个组</li>
<li>j 选择跳转到一个组，可以输入字符搜索，可以跳转到未显示的组</li>
<li>. 移动到<b>第一个</b>含有<b>未读消息</b>的组</li>
</ul>
</div>
</div>

<div id="outline-container-org10e7598" class="outline-4">
<h4 id="org10e7598">组打开退出</h4>
<div class="outline-text-4" id="text-org10e7598">
<ul class="org-ul">
<li>SPC 打开组，进入 <code>*Summary* buffer</code>, 同时<b>自动打开第一个未读的消息</b>。列表只显示了<b>未读</b>的或者<b>标记</b>了的信息。</li>
<li>RET 打开组，不自动打开消息</li>
<li>q 询问是否缓存并退出 GNUS</li>
</ul>
</div>
</div>

<div id="outline-container-org4c2d9d7" class="outline-4">
<h4 id="org4c2d9d7">组标记</h4>
<div class="outline-text-4" id="text-org4c2d9d7">
<ul class="org-ul">
<li>c 标记当前组内 <b>*没有被标记的文章</b>为已读</li>
<li>C 标记当前组内 <b>*所有文章</b>为已读</li>
<li>M m （或 #） 标记当前组</li>
<li>M u （或 M-#） q 取消标记当前组</li>
<li>M U 取消所有标记</li>
<li>M b 标记当前 buffer 的所有组</li>
</ul>
</div>
</div>

<div id="outline-container-orgdeb88cb" class="outline-4">
<h4 id="orgdeb88cb">组管理</h4>
<div class="outline-text-4" id="text-orgdeb88cb">
<p>
管理组都会向服务器<b>发送请求</b>，比如我要新建一个组，那么就会发请求去服务器那边告诉它这边要新建一个组。如果 Outlook 的回收站名字叫 Junk, 我想重命名它，然后后收到服务器那边的拒绝 -&#x2013;&#x2014; 这个是它默认的文件夹，是不让改的。
</p>

<ul class="org-ul">
<li>G m 添加一个组，会被询问名字、方法（协议）、地址等信息</li>
<li>G r 重命名一个组</li>
<li>G p 编辑组参数</li>
<li>G R 添加一个 RSS 组。不会发送到服务器</li>
<li>G DEL 删除组，字面意义上的删除。如果给了前缀 C-u, 删除包括里面的文章。<b>慎用！！！</b></li>
</ul>
</div>
</div>

<div id="outline-container-orgbfcea02" class="outline-4">
<h4 id="orgbfcea02">组显示</h4>
<div class="outline-text-4" id="text-orgbfcea02">
<p>
组可见是指能不能在 <code>*Group*</code> buffer 中显示，并不是它被删除。默认情况下，如果一个组没有了未读文章就会被隐藏，使得我们的注意力可以集中在那些未处理的消息上。
</p>

<ul class="org-ul">
<li>A s （或 l） 显示含有未读文章的组，默认下只显示等级 5 及以下的组——一般组的等级都是 3</li>
<li>A u （或 L） 显示所有组，不管含不含有未读</li>
<li>A m 显示名字正则匹配且含有未读的组。如果输入空就是还原</li>
<li>A M 显示所有名字正则匹配的组</li>
</ul>
</div>
</div>

<div id="outline-container-org3f7e525" class="outline-4">
<h4 id="org3f7e525">组排序</h4>
<div class="outline-text-4" id="text-org3f7e525">
<ul class="org-ul">
<li>G S a 按<b>名字</b>以字母表顺序排序</li>
<li>G S u 按<b>名字</b>以字母表顺序排序含有未读</li>
<li>G S l 按<b>等级</b>排序</li>
<li>G S v 按<b>分数</b>排序</li>
</ul>
</div>
</div>

<div id="outline-container-org963f456" class="outline-4">
<h4 id="org963f456">组其他操作</h4>
<div class="outline-text-4" id="text-org963f456">
<ul class="org-ul">
<li>^ 打开服务器列表，进入 <code>*Server* buffer</code></li>
<li>a 新建一封信息</li>
<li>g 刷新服务器</li>
<li>R 重启 GNUS</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orged6982a" class="outline-3">
<h3 id="orged6982a">组参数</h3>
<div class="outline-text-3" id="text-orged6982a">
<p>
本质上是一个列表，如：
</p>
<div class="org-src-container">
<pre><code class="language-lisp">((to-address . "ding@gnus.org")
 (auto-expire . t))</code></pre>
</div>

<p>
每个组都会有一个这样的列表
</p>

<p>
常用参数：
</p>
<ul class="org-ul">
<li><code>visible</code>, 布尔值，如果设为 <code>t</code> ，那么该组一直可见，即使没有未读文章</li>
<li><code>display</code>, 进入该组时，展示的文章数量
<ul class="org-ul">
<li><code>all</code>, 展示所有文章</li>
<li>整数 N, 表示展示最多 N 篇文章</li>
<li><code>default</code>, 展示默认可见的文章，包括未读和标记，过期的不展示</li>
</ul></li>
<li><code>comment</code>, 一段注释，字符串类型，即要加双引号</li>
<li><code>charset</code>, 字符集</li>
</ul>

<p>
组参数可以在配置文件中批量配置，通过设置变量 <code>gnus-parameters</code> 来实现。
</p>
<div class="org-src-container">
<pre><code class="language-lisp">(setq gnus-parameters
      '(("mail\\..*" (display . all))
        ("list\\..*"
         (total-expire . t)
         (broken-reply-to . t))))</code></pre>
</div>

<p>
第一个参数是用于正则匹配，名字匹配到的组会加上后续的参数。 <code>gnus-parameters-case-fold-search</code> 表明了匹配时是否忽略大小写，默认是忽略。
</p>

<p>
<code>visible</code> 不能通过这种方式设置，有一个变量 <code>gnus-permanently-visible-groups</code> 专门用于设置可见组，它是一个字符串，用于正则匹配的，可以这样配置：
</p>

<div class="org-src-container">
<pre><code class="language-elisp">(setq gnus-permanently-visible-groups
      (string '("pattern-1"
                "pattern-2"
                ; ...)
              "\\|"))</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgcba538e" class="outline-3">
<h3 id="orgcba538e">话题</h3>
<div class="outline-text-3" id="text-orgcba538e">
<p>
话题 Topic, 暂时用不到。
</p>
</div>
</div>
</div>

<div id="outline-container-org815dac6" class="outline-2">
<h2 id="org815dac6">Summary Buffer</h2>
<div class="outline-text-2" id="text-org815dac6">
<p>
文章列表（字面翻译的话就叫“纲要”吧），展示当前组下所有的文章。默认情况下只展示<b>未读文章</b>。
</p>
</div>

<div id="outline-container-orge9fff6d" class="outline-3">
<h3 id="orge9fff6d">纲要操作</h3>
<div class="outline-text-3" id="text-orge9fff6d">
</div>
<div id="outline-container-orge7fa2c9" class="outline-4">
<h4 id="orge7fa2c9">纲要打开与退出</h4>
<div class="outline-text-4" id="text-orge7fa2c9">
<ul class="org-ul">
<li>SPACE/RET 在文章尚未打开时，这两个就是打开文章。如果打开后会变成其它功用</li>
<li>q 退出当前组</li>
<li><p>
c 标记所有未标记的文章为<b>已读</b>，并退出
</p>

<p>
一般用不到，在读完当前组的消息后，再次按翻页或者下一条会自动跳转到下一个有未读消息的组
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orga8c2389" class="outline-4">
<h4 id="orga8c2389">纲要光标移动</h4>
<div class="outline-text-4" id="text-orga8c2389">
<ul class="org-ul">
<li>n 移动到下一未读文章</li>
<li>p 移动到上一未读文章</li>
<li>N 移动到下一篇文章</li>
<li>P 移动到上一篇文章</li>
</ul>
</div>
</div>

<div id="outline-container-org47c37a9" class="outline-4">
<h4 id="org47c37a9">文章滚动与操作</h4>
<div class="outline-text-4" id="text-org47c37a9">
<p>
在 <code>*Summary*</code> buffer 下打开文章会弹出一个 <code>*Article*</code> buffer, 但光标依然停留在 <code>*Summary*</code>, 也就是还能用 n/p/N/P 来选择不同文章，文章的 buffer 内容也会跟着相应变化。
</p>

<p>
此时一些键盘映射已经改变，使得光标即使在纲要的 buffer ，也能对文章 buffer 进行翻页操作。
</p>

<ul class="org-ul">
<li>SPACE 向下翻一页，如果已经达到底部，那么再按 SPACE 就会自动跳转到下一篇<b>未读</b>文章</li>
<li>DEL 向上翻一页</li>
<li>RET 向下滚动一行</li>
<li>M-RET 向上回滚一行</li>
<li>&lt; 回到首行</li>
<li>&gt; 移动到底行</li>
<li>g 重新获取（刷新）文章</li>
<li>s 在文章中渐进搜索（ I-search ），使用 <code>C-s</code> 来向前继续搜索， <code>C-r</code> 来向后搜索</li>
<li>h 选择文章，也就是把光标移动到文章的buffer</li>
</ul>
</div>
</div>

<div id="outline-container-org4b4b8ff" class="outline-4">
<h4 id="org4b4b8ff">文章显示</h4>
<div class="outline-text-4" id="text-org4b4b8ff">
<ul class="org-ul">
<li>/ / （或 / s） 展示相同主题（subject）的文章，加前缀 C-u 则是排除该主题</li>
<li>/ a 展示相同作者的文章，加前缀 C-u 则是排除该主题</li>
<li>/ R 展示相同收件人（recipient）的文章，加前缀 C-u 则是排除该主题</li>
<li>/ A 展示 To, From, Cc 有给定地址的文章，加前缀 C-u 则是排除该主题</li>
<li>/ u （或者 x） 展示未读文章，加前缀 C-u 则展示<b>严格未读</b>的，被标记为标记（ticked）和休眠的都会排除</li>
<li>/ m 展示给定标记的文章</li>
<li>/ t 展示给定天数（days）之内的文章，加前缀 C-u 则是给定天数之外</li>
<li>/ r 展示已回复的文章，加前缀 C-u 则是未回复</li>
<li>/ b 展示（搜索）文章<b>内容</b>匹配给定字符的文章，加前缀 C-u 就是排除。可能会很慢</li>
<li>/ h 展示（搜索）文章<b>头部</b>匹配给定字符的文章，加前缀 C-u 就是排除。可能会很慢</li>
</ul>
</div>
</div>

<div id="outline-container-orge3412d1" class="outline-4">
<h4 id="orge3412d1">邮件操作</h4>
<div class="outline-text-4" id="text-orge3412d1">
<ul class="org-ul">
<li>B DEL 删除当前邮件</li>
<li>B m 移动当前邮件</li>
<li>B c 复制当前邮件</li>
</ul>
</div>
</div>

<div id="outline-container-org24539b9" class="outline-4">
<h4 id="org24539b9">文章搜索</h4>
<div class="outline-text-4" id="text-org24539b9">
<ul class="org-ul">
<li>M-s 向后搜索</li>
<li>M-r 向前搜索</li>
<li>M-S 重复向后搜索</li>
<li>M-R 重复向前搜索</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1d925cd" class="outline-3">
<h3 id="org1d925cd">文章发送</h3>
<div class="outline-text-3" id="text-org1d925cd">
</div>
<div id="outline-container-orgec1ff29" class="outline-4">
<h4 id="orgec1ff29">邮件撰写</h4>
<div class="outline-text-4" id="text-orgec1ff29">
<ul class="org-ul">
<li>m 准备一封邮件进行撰写。使用默认样式。</li>
<li>S i 准备一则新闻，默认会发送到当前组。</li>
<li>S D b 重新准备<b>未发送成功</b>的邮件。</li>
<li>S D r 重新准备<b>未发送成功</b>的邮件，需要重新指定地址。</li>
<li>S D e 重新准备<b>未发送成功</b>的邮件，需要重新编辑内容。</li>
</ul>
</div>
</div>

<div id="outline-container-org7fb771c" class="outline-4">
<h4 id="org7fb771c">文章回复</h4>
<div class="outline-text-4" id="text-org7fb771c">
<ul class="org-ul">
<li>r 回复当前文章的作者</li>
<li>R 回复当前文章的作者，并附上文章的原始内容</li>
<li>S w 广泛回复，回复给文章中的 To, From 和抄送列表的所有人</li>
<li>S W 广泛回复，并附上文章的原始内容</li>
</ul>
</div>
</div>

<div id="outline-container-org4b3599c" class="outline-4">
<h4 id="org4b3599c">文章撰写</h4>
<div class="outline-text-4" id="text-org4b3599c">
<ul class="org-ul">
<li>S p （或 a） 准备一篇文章，默认发到当前组。</li>
<li>S f （或 f） 发送一篇后续（followup）到当前文章</li>
<li>S F （或 F） 发送一篇后续（followup）到当前文章，并附上当前文章的原始内容</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6eb2643" class="outline-3">
<h3 id="org6eb2643">文章标记</h3>
<div class="outline-text-3" id="text-org6eb2643">
</div>
<div id="outline-container-org01d2a2f" class="outline-4">
<h4 id="org01d2a2f">文章标记样式</h4>
<div class="outline-text-4" id="text-org01d2a2f">
<ul class="org-ul">
<li>'!' <b>标记</b>（ticked），它意味着不管读没读过该文章都<b>一直可见</b>，但是会过期。</li>
<li>'?' <b>休眠</b>，它只有在文章有后续更新时才会显示</li>
<li>'r' <b>已读</b>，不一定真的读了，它是被用户标记为已读状态</li>
<li>'R' <b>真已读</b>，真的被浏览了</li>
<li>'O' <b>过时</b>，之前被标记为已读，但现在已经有更新</li>
<li>'K' <b>删除</b>，被标记的</li>
<li>'X' <b>删除</b>，指文件已经不存在</li>
<li>'C' <b>赶上</b>（catchup）</li>
<li>'G' <b>取消</b></li>
<li>'M' <b>重复</b></li>
<li>'E' <b>过期</b></li>
</ul>
</div>
</div>

<div id="outline-container-org31d3aab" class="outline-4">
<h4 id="org31d3aab">文章标记操作</h4>
<div class="outline-text-4" id="text-org31d3aab">
<ul class="org-ul">
<li>! 标记当前文章为<b>标记</b>（ticked）</li>
<li>? 标记当前文章为<b>休眠</b></li>
<li>M-u 标记当前文章为<b>未读</b></li>
<li>d 标记当前文章为<b>已读</b></li>
<li>D 标记当前文章为<b>已读</b>，光标向上移动一行
<ul class="org-ul">
<li>M C-c 标记<b>所有</b>文章为<b>已读</b></li>
</ul></li>
<li>E 标记当前文章为<b>过期</b></li>
<li>M b 给当前文章设置书签</li>
<li>M B 移除当前文章的所有书签</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd89cb79" class="outline-3">
<h3 id="orgd89cb79">文章排序</h3>
<div class="outline-text-3" id="text-orgd89cb79">
<p>
默认文章排序可以通过初始化变量 <code>gnus-article-sort-functions</code>, 它是一个列表，包含了各种排序函数，<b>最后一个函数是主要的排序函数</b>。内置的函数有：
</p>
<ul class="org-ul">
<li>gnus-article-sort-by-number 按序号排序，默认值，建议是第一个</li>
<li>gnus-summary-sort-by-most-recent-number 按最近序号排序</li>
<li>gnus-article-sort-by-author 按作者排序</li>
<li>gnus-summary-sort-by-recipient 按收件人排序</li>
<li>gnus-article-sort-by-subject 按主题排序</li>
<li>gnus-article-sort-by-date 按日期排序</li>
<li>gnus-summary-sort-by-most-recent-date 按最近日期排序</li>
<li>gnus-article-sort-by-score 按分数排序</li>
<li>gnus-summary-sort-by-lines 按文章行数排序</li>
<li>gnus-summary-sort-by-chars 按文章子树排序</li>
<li>gnus-article-sort-by-random 随机排序</li>
</ul>

<p>
我的配置是：
</p>
<div class="org-src-container">
<pre><code class="language-lisp">(setq gnus-article-sort-functions
      '(gnus-article-sort-by-number
        gnus-summary-sort-by-most-recent-date))</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8b803ba" class="outline-2">
<h2 id="org8b803ba">Article Buffer</h2>
<div class="outline-text-2" id="text-org8b803ba">
<p>
文章内容的 buffer, 用于展示文章的内容（废话）。
</p>

<ul class="org-ul">
<li>SPACE 向下滚动一页</li>
<li>DEL 向上滚动一页</li>
<li>C-c C-m 准备一封回信给光标附近的地址</li>
<li>h （或 s） 光标在回到 <code>*Summary*</code> 和 <code>*Article*</code> 间切换</li>
<li>TAB 移动到下一个<b>可点击处</b></li>
<li>M-TAB 移动到上一个可点击处</li>
<li>R 准备一篇回复给当前文章，并附上文章内容。如果选定了区域，只附上选定的内容</li>
<li>S W 准备一篇广回复</li>
<li>F 准备一篇后续</li>
</ul>
</div>
</div>

<div id="outline-container-org583e146" class="outline-2">
<h2 id="org583e146">信息发送</h2>
<div class="outline-text-2" id="text-org583e146">
<p>
在<a href="#org1d925cd">文章发送</a>那里写好邮件，通过 <code>C-c C-c</code> 发送最后一封编辑的邮件
</p>
</div>

<div id="outline-container-org501ac16" class="outline-4">
<h4 id="org501ac16">定时发送</h4>
<div class="outline-text-4" id="text-org501ac16">
<p>
需要在配置里面加上：
</p>
<div class="org-src-container">
<pre><code class="language-lisp">(gnus-delay-initialize)</code></pre>
</div>
<p>
它会初始化 delay 相关的包，和定制键盘映射。
</p>

<p>
在编辑邮件时 <code>C-c C-j</code> 来定时发送邮件。
</p>

<p>
<b>定时发送</b>可以设置的选项：
</p>
<ul class="org-ul">
<li>一段时间，如“42d”，那么就会在 42 天之后发送。有 m (分钟), h (小时), d (天), w (周), M (月), Y (年) 。</li>
<li>具体日期，格式“YYYY-MM-DD”，然后会在 <code>gnus-delay-default-hour</code> 这个时间点发送，默认是 8:00 am.</li>
<li>具体时间，格式“hh:mm”， 24 小时制。如果当前时间在其之前，那么今天到点就发；否则，明天发。</li>
</ul>

<p>
它会在邮件头上加上一个头 <code>gnus-delay-header</code> ，默认是“X-Gnus-Delayed”，它的值是要发送的日期。
</p>
</div>
</div>

<div id="outline-container-org101efa5" class="outline-4">
<h4 id="org101efa5">草稿</h4>
<div class="outline-text-4" id="text-org101efa5">
<p>
对于一封正在写的信，可以通过 <code>C-x C-s</code> 即 buffer 保存键把其保存到草稿，即 <code>nndraft:drafts</code> 组中，进入之后，可以进行的操作：
</p>
<ul class="org-ul">
<li>D e 编辑该草稿</li>
<li>D s 发送当前草稿</li>
<li>D S 发送所有草稿</li>
<li>D t 开关发送标志</li>
<li>B DEL 删除当前草稿</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org7101619" class="outline-2">
<h2 id="org7101619">RSS</h2>
<div class="outline-text-2" id="text-org7101619">
<p>
目前我的做法是在配置文件中维护一份 RSS 列表，在每次启动 GNUS 之后检查，如果没有的话自动添加。
</p>
<div class="org-src-container">
<pre><code class="language-lisp">(defvar rss-list
  '(("Emacs China - 最新话题" . "https://emacs-china.org/latest.rss")
    ;; ...
    ))

;; 原生版本
(add-hook 'gnus-group-prepare-hook
          #'(lambda ()
              (dolist (it rss-list)
               (unless (gnus-group-entry (concat "nnrss:" (car it)))
                 (let ((title (car it))
                       (href (cdr it)))
                   (gnus-group-make-group title '(nnrss ""))
                   (push (list title href title) nnrss-group-alist))))
              (nnrss-save-server-data nil)))

;; dash.el 版本
(add-hook 'gnus-group-prepare-hook
          #'(lambda ()
              (--map-when
               (not (gnus-group-entry (concat "nnrss:"
                                              (car it))))
               (let ((title (car it))
                     (href (cdr it)))
                 (gnus-group-make-group title '(nnrss ""))
                 (push (list title href title) nnrss-group-alist))
               rss-list)
              (nnrss-save-server-data nil)))</code></pre>
</div>
</div>

<div id="outline-container-org06f0263" class="outline-3">
<h3 id="org06f0263">通过 Feeddd 获取微信公众号</h3>
<div class="outline-text-3" id="text-org06f0263">
<p>
微信公众号自身不提供 RSS, 但是还是有高手做了项目，比如 <a href="https://feeddd.org/" target="_blank">Feeddd</a>. 但是我发现 Feeddd 的 rss 都是只有个标题和一条超链接，点击超链接之后装到微信官方的站点去查看，甚是不便。于是我便根据 Emacs 内置的浏览器 <a href="https://www.gnu.org/software/emacs/manual/html_mono/eww.html" target="_blank">EWW</a> 获取文章内容， EWW 会把文章内容渲染好之后输出到一个 buffer ，再把它覆盖到邮件里——只是改了 buffer 内容，不会真地去改变 rss 原来的内容。
</p>

<p>
但是<b>图片显示不出来</b>。这是 EWW 的问题，因为它不加载 js ——如果图片是 HTML 标签就会加载；如果是通过 js 插入的就不行。而微信属于后者。我觉得懒猫大神的 EAF 应该可以做到。
</p>

<div class="org-src-container">
<pre><code class="language-lisp">(defun my/gnus--wechat-need-fetch (group)
  "Check the gourp's uri. GROUP is a string"
  (let ((uri (cdr (assoc-string group rss-list))))
    (and uri
         (string-match-p "api.feedd" uri))))

(defvar my/eww--sig nil)

(defun my/eww--set-sig ()
  "Set singal when EWW is loaded."
  (setq my/eww--sig t))

(defun my/gnus-fetch-content-from-wechat ()
  "Fetch content from wechat link in the posts

TODO: Images don't show up, while other sites do."
  (when (and gnus-article-current
             (string-match-p "^nnrss" (car gnus-article-current))
             (my/gnus--wechat-need-fetch nnrss-group))
    (save-excursion
      (with-current-buffer gnus-article-buffer
        (re-search-forward "^link$")
        (backward-char)
        (let ((uri (get-text-property (point) 'shr-url))
              (res ""))
          (save-excursion
            (add-hook 'eww-after-render-hook #'my/eww--set-sig)
            (eww uri)
            ;; 我没找到 EWW 渲染完成的接口
            ;; 于是写了个计时器，每秒检查一次，5 秒超时
            (with-timeout (5 nil)
              (while (not my/eww--sig)
                (sleep-for 1))
              (setq res (buffer-string)
                    my/eww--sig nil))
            (remove-hook 'eww-after-render-hook #'my/eww--set-sig))
          (when (length> res 0)
            (read-only-mode -1)
            (beginning-of-line)
            (delete-to-end-of-line)
            (insert res)
            (read-only-mode 1)))))
    (quit-window)))

;; 添加钩子
(add-hook 'gnus-article-prepare-hook #'my/gnus-fetch-content-from-wechat)</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge468ec4" class="outline-2">
<h2 id="orge468ec4">后记</h2>
<div class="outline-text-2" id="text-orge468ec4">
<p>
目前这些操作已经完全满足我的日常使用场景了，如果后续有新的体会或改动的话再更新。
</p>
</div>
</div>
<div id="footnotes">
<hr>
<div class="text-footnotes" role="doc-endnotes">
<ol>
<li id="fn:1">
<p class="footpara">
<a href="https://en.wikipedia.org/wiki/Gnus" target="_blank">Gnus - Wikipedia</a>
<a href="#fnr:1.1" class="footnote-backref" role="doc-backlink">↩︎</a>
</p>
</li>
<li id="fn:2">
<p class="footpara">
<a href="https://blog.csdn.net/luixiao1220/article/details/88532912" target="_blank">emacs之使用gnus读取和发送新浪邮件_luixiao1220的博客-CSDN博客</a>
<a href="#fnr:2.1" class="footnote-backref" role="doc-backlink">↩︎</a>
</p>
</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<script src="/static/mermaid/mermaid.min.js"></script>
<script>
mermaid.initialize({theme: 'neutral', securityLevel: 'loose'});
</script>
<script src="/static/highlight/highlight.min.js"></script>
<script>
Array.from(document.querySelectorAll('#content pre')).forEach(
node => {
let codeElement = node.querySelector("code"),
    excludes = ["mermaid"];

if (!codeElement){
return
}
let language = codeElement.getAttribute("class").split("-")[1];
if (excludes.includes(language)) {
return
}

hljs.highlightElement(codeElement);
});
</script></div>
</div>
<div class="footer">
<center> The End </center></div>
</body>
</html>
